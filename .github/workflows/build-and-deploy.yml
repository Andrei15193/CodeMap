name: Build and Deploy

on:
  push:
    branches:
    - dev
    - add-basic-tooling

  release:
    types:
    - published

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Generate Package Info
      id: package_info
      if: false
      shell: pwsh
      run: |
        $codeMapDescription = (Select-Xml -Path ./CodeMap/CodeMap.csproj -XPath "//Project/PropertyGroup/Description/text()").Node.Data.Trim() -replace '\r?\n\r?','%0A'
        $codeMapReleaseNotes = (Select-Xml -Path ./CodeMap/CodeMap.csproj -XPath "//Project/PropertyGroup/PackageReleaseNotes/text()").Node.Data.Trim() -replace '\r?\n\r?','%0A'
        Write-Host "::set-output name=package_version::$packageVersion"
        Write-Host "::set-output name=assembly_version::$assemblyVersion"
        Write-Host "::set-output name=codemap_package_description::$codeMapDescription"
        Write-Host "::set-output name=codemap_package_release_notes::$codeMapReleaseNotes"
        [Convert]::FromBase64String("${{ secrets.KeyFile }}") | Set-Content ./CodeMap.snk -AsByteStream

    - name: Setup .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 6.0.x

    - name: Restore
      run: dotnet restore

    - name: Build
      shell: pwsh
      run: |
        $additionalBuildArgs = @()

        if ('${{ github.event_name }}' -ieq 'release') {
          [string] $baseVersionPart, [string] $preReleaseVersionPart = '${{ github.ref_name }}' -split '\-'
          [int] $major, [int] $minor, [int] $revision = $baseVersionPart -split '\.', 3

          # The build version represents a build of the same sources, this seldom happens with releases.
          # Pre-releases have only major and minor version leaving the build and revision numbers as undefined.
          #
          # Releases map the major, minor and patch version numbers to major, minor and revision respectively,
          # leaving the build number to always be 0. If there will be a case where the same sources are build
          # and released in a separate NuGet package it will be addressed at that point, right now I don't see
          # how that will ever happen since releases are tagged in git (must be unique) using SemVer.
          #
          # https://learn.microsoft.com/dotnet/api/system.version
          # https://semver.org
          [string] $version = "$major.$minor.0.$revision"

          if ($preReleaseVersionPart -ne [string]::Empty) {
            $version = "$major.$minor"
          }

          $additionalBuildArgs += "-property:Version=$version"
        }

        $additionalBuildArgs += '-property:InformationalVersion=${{ github.ref_name }}'

        [Convert]::FromBase64String('${{ secrets.KeyFile }}') `
        | Set-Content ./CodeMap.snk -AsByteStream

        dotnet build `
          --configuration Release `
          --no-restore `
          -property:SignAssembly=True `
          -property:AssemblyOriginatorKeyFile=../CodeMap.snk `
          -property:DisableStrongNamer=False `
          @additionalBuildArgs

    - name: Test
      shell: pwsh
      if: false
      run: |
        dotnet test `
          --configuration Release `
          --no-build `
          --verbosity normal

    - name: Pack
      if: github.event_name == 'release'
      shell: pwsh
      run: |
        dotnet pack `
          --configuration Release `
          --output publish `
          --no-build `
          -property:PackageVersion='${{ github.ref_name }}' `
          -property:RepositoryCommit='${{ github.sha }}'

    - name: Upload CodeMap NuGet Package to Release
      uses: actions/upload-release-asset@v1
      if: github.event_name == 'release'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./publish/CodeMap.${{ github.ref_name }}.nupkg
        asset_name: CodeMap.${{ github.ref_name }}.nupkg
        asset_content_type: application/zip

    - name: Generate Project Site
      shell: pwsh
      run: |
        [string] $documentationDirectoryPath = if ('${{ github.ref_name }}' -ieq 'dev') { '${{ github.ref_name }}' } else { 'dev/${{ github.ref_name }}' }
        dotnet run `
          --project CodeMap.Documentation `
          --configuration Release `
          --no-build `
          -- `
          -OutputFilePath "./docs/$documentationDirectoryPath/index.html"

        New-Item `
          -Type Directory `
          -Name docs `
          -ErrorAction SilentlyContinue
        New-Item `
          -Type Directory `
          -Name _data `
          -Path docs `
          -ErrorAction SilentlyContinue

        Copy-Item `
          -Path 'CodeMap.Documentation/GitHub Pages' `
          -Destination './docs' `
          -Recurse

        git tag `
        | ForEach-Object { "- $_" } `
        | Out-File ./docs/_data/tags.yml -Encoding utf8

    - name: Publish Project Site
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./docs
        destination_dir: docs
        enable_jekyll: true
        keep_files: true
